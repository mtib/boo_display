esphome:
  name: boo-display
  friendly_name: Boo Display
  includes:
    - nvs_helper.h
  on_boot:
    - priority: 600
      then:
        - lambda: |-
            disableCore0WDT();
            disableCore1WDT();
    - priority: -10
      then:
        - lambda: |-
            id(boot_count) += 1;
            id(boot_count_sensor).publish_state(id(boot_count));
            // Log reset reason for crash diagnosis
            const char* rr;
            switch (esp_reset_reason()) {
              case ESP_RST_POWERON:  rr = "POWERON";  break;
              case ESP_RST_EXT:      rr = "EXT";      break;
              case ESP_RST_SW:       rr = "SW";       break;
              case ESP_RST_PANIC:    rr = "PANIC";    break;
              case ESP_RST_INT_WDT:  rr = "INT_WDT";  break;
              case ESP_RST_TASK_WDT: rr = "TASK_WDT"; break;
              case ESP_RST_WDT:      rr = "WDT";      break;
              case ESP_RST_BROWNOUT: rr = "BROWNOUT"; break;
              default:               rr = "UNKNOWN";  break;
            }
            ESP_LOGI("boot", "Reset reason: %s", rr);
            // Read state from NVS
            nvs_handle_t nvs;
            if (nvs_open("boo", NVS_READONLY, &nvs) == ESP_OK) {
              size_t len = 0;
              if (nvs_get_str(nvs, "text", nullptr, &len) == ESP_OK && len > 0) {
                char* buf = new char[len];
                if (nvs_get_str(nvs, "text", buf, &len) == ESP_OK) {
                  id(scroll_text) = std::string(buf);
                  ESP_LOGI("boot", "Restored text: %s", buf);
                }
                delete[] buf;
              }
              uint8_t blink_val = 0;
              if (nvs_get_u8(nvs, "blinking", &blink_val) == ESP_OK) {
                id(blinking) = blink_val != 0;
                ESP_LOGI("boot", "Restored blinking: %s", id(blinking) ? "true" : "false");
              }
              nvs_close(nvs);
            }
            id(scroll_text_input).publish_state(id(scroll_text));
            ESP_LOGI("boot", "Boot count: %d, blinking: %s, text: %s", id(boot_count), id(blinking) ? "true" : "false", id(scroll_text).c_str());
        - delay: 200ms
        - lambda: id(boot_init) = false;
        - if:
            condition:
              lambda: "return !id(blinking);"
            then:
              - light.control:
                  id: rgb_led
                  state: on
                  brightness: 20%
                  red: 0%
                  green: 0%
                  blue: 100%
                  transition_length: 0s

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:

api:
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Boo-Display Fallback"
    password: !secret ap_password

captive_portal:

web_server:
  port: 80

i2c:
  sda: GPIO16
  scl: GPIO17
  scan: true
  frequency: 400kHz

sensor:
  - platform: template
    name: "Boot Count"
    id: boot_count_sensor
    lambda: "return id(boot_count);"
    update_interval: never
  - platform: dht
    model: DHT11
    pin: GPIO13
    temperature:
      name: "Temperature"
      id: temperature
      filters:
        - calibrate_linear:
            datapoints:
              - 6.8 -> 8
              - 24 -> 21
    humidity:
      name: "Humidity"
      id: humidity
    update_interval: 10s

globals:
  - id: blinking
    type: bool
    restore_value: false
    initial_value: "false"
  - id: blink_state
    type: bool
    restore_value: false
    initial_value: "false"
  - id: scroll_text
    type: std::string
    restore_value: false
    initial_value: '"Boo!"'
  - id: scroll_x
    type: int
    restore_value: false
    initial_value: "128"
  - id: boot_count
    type: int
    restore_value: true
    initial_value: "0"
  - id: boot_init
    type: bool
    restore_value: false
    initial_value: "true"

interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: "return id(blinking);"
          then:
            - lambda: |-
                id(blink_state) = !id(blink_state);
                if (id(blink_state)) {
                  id(red_output).set_level(1.0);
                  id(green_output).set_level(0.0);
                  id(blue_output).set_level(0.0);
                } else {
                  id(red_output).set_level(0.0);
                  id(green_output).set_level(0.0);
                  id(blue_output).set_level(0.0);
                }

binary_sensor:
  - platform: template
    id: blinking_sensor
    name: "Blinking"
    lambda: "return id(blinking);"
  - platform: gpio
    pin:
      number: GPIO12
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Button"
    id: button
    on_press:
      then:
        - lambda: |-
            id(blinking) = false;
            id(blink_state) = false;
            nvs_handle_t nvs;
            if (nvs_open("boo", NVS_READWRITE, &nvs) == ESP_OK) {
              nvs_set_u8(nvs, "blinking", 0);
              nvs_commit(nvs);
              nvs_close(nvs);
            }
        - light.control:
                  id: rgb_led
                  state: on
                  brightness: 20%
                  red: 0%
                  green: 0%
                  blue: 100%
                  transition_length: 0s

output:
  - platform: ledc
    pin:
      number: GPIO14
      mode:
        output: true
        pulldown: true
    id: red_output

  - platform: ledc
    pin:
      number: GPIO27
      mode:
        output: true
        pulldown: true
    id: green_output

  - platform: ledc
    pin:
      number: GPIO26
      mode:
        output: true
        pulldown: true
    id: blue_output

light:
  - platform: rgb
    name: "RGB LED"
    id: rgb_led
    red: red_output
    green: green_output
    blue: blue_output
    default_transition_length: 0s

text:
  - platform: template
    name: "Scroll Text"
    id: scroll_text_input
    optimistic: true
    min_length: 1
    max_length: 128
    mode: text
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("text", "on_value fired: %s", x.c_str());
            bool text_changed = (x != id(scroll_text));
            id(scroll_text) = x;
            if (text_changed) {
              id(scroll_x) = 128;
            }
            if (!id(boot_init) && text_changed) {
              id(blinking) = true;
              // Persist to NVS
              nvs_handle_t nvs;
              if (nvs_open("boo", NVS_READWRITE, &nvs) == ESP_OK) {
                nvs_set_str(nvs, "text", x.c_str());
                nvs_set_u8(nvs, "blinking", 1);
                nvs_commit(nvs);
                nvs_close(nvs);
              }
            }

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    update_interval: 50ms
    lambda: |-
      it.printf(0, 0, id(font_small), "%.1fÂ°C", id(temperature).state);
      it.printf(128, 0, id(font_small), TextAlign::TOP_RIGHT, "%.0f%%", id(humidity).state);
      // separator removed
      int x1, y1, tw, th;
      it.get_text_bounds(0, 0, id(scroll_text).c_str(), id(font_big), TextAlign::TOP_LEFT, &x1, &y1, &tw, &th);
      if (tw <= 128) {
        // Text fits on screen, display at x=0 without scrolling
        it.print(0, 16, id(font_big), id(scroll_text).c_str());
      } else {
        // Text doesn't fit, scroll it
        it.print(id(scroll_x), 16, id(font_big), id(scroll_text).c_str());
        id(scroll_x) -= 1;
        if (id(scroll_x) < -tw) {
          id(scroll_x) = 128;
        }
      }

font:
  - file: "gfonts://Oswald@300"
    id: font_small
    size: 16
  - file: "gfonts://Oswald@300"
    id: font_big
    size: 32
